// class MapManager has the simulated map which the robot generates
// it also finds the frontiers of the map and updates the map based on the laser scan data
using System;
using System.Collections.Generic;
using RosMessageTypes.Sensor;
using RosMessageTypes.Std;
using RosMessageTypes.BuiltinInterfaces;
using Unity.Robotics.Core;
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using UnityEngine.Serialization;

public class MapManager : MonoBehaviour
{
    public int gridSize = 100; // size of the grid 1m x 1m since plane is that size
    public float cellSize = 0.01f; // each cell is one grid of 1cm
    public int[,] mapGrid; // 2D array to represent the map generated by the robot, 1=occupied, 0=free, -1=unknown

    public LaserScanSensor laserScanSensor;

    public float[] ranges = laserScanSensor.GetRanges();

    public void Start()
    {
        InitializeMap();


    }

    // sets all cells in the map to -1 (unknown cells)
    public void InitializeMap()
    {
        mapGrid = new int[gridSize, gridSize];
        for (int i = 0; i < gridSize; i++)
        {
            for (int j = 0; j < gridSize; j++)
            {
                mapGrid[i, j] = -1;
            }
        }
    }


    public void UpdateMap()
    {
        if (laserScanSensor == null || ranges.Count == 0)
        {
            Debug.LogError("laserScanSensor is null or ranges has count of 0.");
            return;
        }

        Vector3 robotPosition = laserScanSensor.transform.position;
        // Convert world positions to grid indices
        
        int robotX = Mathf.FloorToInt(robotPosition.x / cellSize);
        int robotY = Mathf.FloorToInt(robotPosition.z / cellSize); // z is forward

        // basically has the way that the robot is facing / is rotated
        float robotYRotation = laserScanSensor.transform.eulerAngles.y;

        // angle increment for determining the angle change every time the laser scan takes a scan
        if (laserScanSensor.NumMeasurementsPerScan == 0) return;
        float angleIncrement = (laserScanSensor.ScanAngleEndDegrees - laserScanSensor.ScanAngleStartDegrees) / laserScanSensor.NumMeasurementsPerScan;

        for (int i = 0; i < ranges.Count; i++)
        {


            float distance = ranges[i];
            if (distance <= 0f) continue;
            float angleDeg = laserScanSensor.ScanAngleStartDegrees + i * angleIncrement + robotYRotation;
            float angleRad = angleDeg * Mathf.Deg2Rad;

            Vector3 laserHitPoint = robotPosition + new Vector3(
                Mathf.Cos(angleRad) * distance,
                0,
                        Mathf.Sin(angleRad) * distance
                );

            int hitX = Mathf.FloorToInt(laserHitPoint.x / cellSize);
            int hitY = Mathf.FloorToInt(laserHitPoint.z / cellSize); // use z for 2D plane depth

            MarkLineAsFree(robotX, robotY, hitX, hitY);
            if (hitX >= 0 && hitX < gridSize && hitY >= 0 && hitY < gridSize)
            {
                mapGrid[hitX, hitY] = 1;

            }
        }


        void MarkLineAsFree(int x0, int y0, int x1, int y1)
        {
            int dx = Mathf.Abs(x1 - x0);
            int dy = Mathf.Abs(y1 - y0);
            int sx = (x0 < x1) ? 1 : -1;
            int sy = (y0 < y1) ? 1 : -1;
            int err = dx - dy;


            while (x0 != x1 || y0 != y1)
            {
                if (x0 >= 0 && x0 < gridSize && y0 >= 0 && y0 < gridSize)
                {
                    if (mapGrid[x0, y0] != 1)
                    {
                        mapGrid[x0, y0] = 0;
                    }


                }

                int e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }


    }



}



