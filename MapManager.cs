// class MapManager has the simulated map which the robot generates
// it also finds the frontiers of the map and updates the map based on the laser scan data
using System;
using System.Collections.Generic;
using RosMessageTypes.Sensor;
using RosMessageTypes.Std;
using RosMessageTypes.BuiltinInterfaces;
using Unity.Robotics.Core;
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using UnityEngine.Serialization;

public class MapManager : MonoBehaviour
{
    public int gridSize = 100; // size of the grid 1m x 1m since plane is that size
    public float cellSize = 0.01f; // each cell is one grid of 1cm
    public int[,] mapGrid; // 2D array to represent the map generated by the robot, 1=occupied, 0=free, -1=unknown

    public LaserScanSensor laserScanSensor;

    public void Start()
    {
        InitializeMap();


    }

    // sets all cells in the map to -1 (unknown cells)
    public void InitializeMap()
    {
        mapGrid = new int[gridSize, gridSize];
        for (int i = 0; i < gridSize; i++)
        {
            for (int j = 0; j < gridSize; j++)
            {
                mapGrid[i, j] = -1;
            }
        }
    }


    public void UpdateMap()
    {
        if (laserScanSensor == null && laserScanSensor.ranges.Count == 0)
        {
            Debug.LogError("laserScanSensor is null or ranges has count of 0.");
            return;
        }

        Vector3 robotPosition = laserScanSensor.transform.position;

        // basically has the way that the robot is facing / is rotated
        float robotYRotation = laserScanSensor.transform.eulerAngles.y;

        // angle increment for determining the angle change every time the laser scan takes a scan
        float angleIncrement = (laserScanSensor.ScanAngleEndDegrees - laserScanSensor.ScanAngleStartDegrees) / laserScanSensor.NumMeasurementsPerScan;

        for (int i = 0; i < laserScanSensor.ranges.Count; i++)
        {
            
        }


    }



}



